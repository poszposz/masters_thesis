\chapter{Tworzenie oprogramowania}
\label{cha:tworzenie_oprogramowania}

\section{Opis użytej technologii i bibliotek}

W celu implementacji aplikacji serwerowej użyto biblioteki Node.js, jest to stosunkowo nowa technologia, jej pierwsza wersja ujrzała światło dzienne w roku 2009. Node.js umożliwia wykonywanie kodu Javascript poza przeglądarką użytkownika, po stronie serwerowej, składa się z silnika V8 zaimplementowanego przez firmę Google oraz zestawu bibliotek dołączonych przez twórcę języka w celu stworzenia wieloplatformowego środowiska do uruchamiania skryptów napisanych w kodzie Javascript. Biblioteka Node.js jest zaimplementowana w oparciu o architekturę \textit{event-driven} i asynchroniczne operacje wyjścia i wejścia, co oznacza, że biblioteka wydajnie wykorzystuje wielowątkowość i nie zostaje zablokowana wykonywaniem długich operacji przez równolegle działające procesy. Zważając na opisane wcześniej charakterystyki, oprogramowanie stworzone przy użyciu Node.js wyróżnia się dużą wydajnością oraz optymalnym wyborem dla aplikacji oczekujących szybkiego przetwarzania lub komunikacji w czasie rzeczywistym. Dodatkową zaletą biblioteki Node.js jest fakt, że wykorzystuje ten sam język programowania, którego używa się do programowania stron internetowych, z racji tego bariera wejścia do tworzenia pełnych systemów jest znacznie mniejsza.
Aplikacja serwerowa korzysta z wielu pomocniczych bibliotek, które umożliwiają szybsze tworzenie kodu. Standardowym oprogramowaniem służącym do zarządzania zewnętrznymi bibliotekami jest aplikacja \textit{npm}, jednak podczas tworzenia tego projektu użyto aplikacji \textit{yarn}, która działa w bardzo przybliżony sposób, zabezpiecza jednak przed usunięciem przez twórcę oprogramowania kodu źródłowego każdej z bibliotek. W poniższych punktach opisano kilka wybranych bibliotek użytych do stworzenia aplikacji wraz z krótkim opisem i przykładem użycia:\newline

\textbf{Express} - biblioteka służąca do pisania aplikacji serwerowych przy użyciu biblioteki Node.js. Udostępnia prosty interfejs do tworzenia punktów końcowych i jest określana jako jeden ze standardów podczas tworzenia aplikacji serwerowych przy użyciu Node.\newline

\textbf{Eslint} - biblioteka służąca jako tzw. \textit{linter} , czyli proces na bieżąco sprawdzający jakość kodu pisanego przez użytkownika. Dzięki użyciu eslint programista nie musi martwić się o niejednorodność we wcięciach, nieużywane zmienne czy niepoprawne ilości znaków białych, jest to sprawdzane przez program. Eslint korzysta z pliku .eslintrc który definiuje wszystkie zasady które mają być spełnione w projekcie, aby kod został uznany za bezbłędny.\newline

\textbf{Axios} - biblioteka umożliwiająca proste interakcje z interfejsami serwerowymi innych serwisów. Dzięki stworzeniu globalnego klienta axios zawierającego podstawową konfigurację nie ma potrzeby powielać tych samych konfiguracji w wielu zapytaniach, wystarczy jedynie zdefiniować rzeczy, które się różnią, jak na przykład URL czy metoda HTTP.\newline

\textbf{Cors} - w celu komunikacji aplikacji serwerowej i strony internetowej znajdujących się pod jednym adresem IP należy skonfigurować \textit{„Cross Origin Resource Sharing”}. Ma to zapobiec możliwości przesyłania złośliwych skryptów w formularzach, które zostaną wykonane przez aplikację. Do umożliwienia Cross Origin Resource Sharing użyto biblioteki cors, która po inicjalizacji automatycznie dodaje nagłówek HTTP Access-Control-Allow-Origin z odpowiednią domeną, dla której tego typu zapytania mają być możliwe.\newline

Aplikacja w celu wyznaczania tras korzysta z dwóch zewnętrznych serwisów - ZiKIT Carto oraz openstreetmap. Carto jest to platforma do zarządzania danymi geoprzestrzennymi, która umożliwia pobranie, wizualizację oraz przeszukiwanie dróg przy użyciu odpowiednich komend SQL. Kod carto jest otwarty i każdy może uruchomić go w swojej stronie internetowej w celu uproszczonej wizualizacji tras na mapie. Krakowski ZiKIT korzysta z własnej instancji carto w celu wizualizacji i przetrzymywania wszelkiego rodzaju danych, takich jak zbiory różnych typów dróg oraz wydarzenia (np. wypadki samochodowe) na mapach. Openstreetmap jest to darmowy portal udostępniający usługę map oraz oferujący szeroki zakres innych danych geoprzestrzennych. Openstreetmap jest projektem otwartym, portal jest utrzymywany przez fundację o tej samej nazwie, a swoje dane zawdzięcza użytkownikom, którzy wprowadzają je w celu ich późniejszego wykorzystania lub jako wolontariusze.

\subsection{Opis udostępnionych endpointów}

W celu umożliwienia komunikacji aplikacji mobilnej oraz strony internetowej, przygotowana aplikacja serwerowa udostępnia pod zdefiniowanymi adresami URL end-point’y, które po przekazaniu odpowiednich parametrów w kwerendzie, umożliwiają pobranie danych. Zaimplementowano je przy pomocy obiektu \textit{router}, będącego częścią opisanej wcześniej biblioteki express.
Poniżej przedstawiono dwa end-point’y udostępnione przez aplikację razem z dokumentacją oraz przykładową, skróconą, odpowiedzią w formacie JSON:
\begin{enumerate}
\item Endpoint findOptimized

Używany przez aplikację mobilną w celu pobrania optymalnej trasy pomiędzy dwoma punktami przekazanymi w formie kwerendy. Wykorzystuje metodę HTTP GET. Możliwe parametry do przekazania w kwerendzie URL:

\begin{itemize}
\item startLocation - parametr określający punkt początkowy wyznaczonej trasy w przypadku, gdy jest on przekazany jako adres.
\item startLocationLatitude oraz startLocationLongitude - przez te parametry zostaje przekazana pozycja użytkownika w przypadku, gdy zostaje ona zdefiniowana przez współrzędne geograficzne punktu początkowego. Jeśli lokalizacja punktu początkowego zostaje przekazana w tej postaci, parametr startLocation zostaje zignorowany, niezależnie od tego czy został zdefiniowany w kwerendzie.
\item endLocation - parametr określający punkt końcowy trasy w postaci adresu. Aplikacja nie daje możliwości przekazania punktu końcowego trasy w postaci współrzędnych geograficznych, dlatego też w przypadku punktu końcowego trasy przekazanie lokalizacji w tej postaci nie zostało zaimplementowane.
\item routeType - określenie czy wyznaczona trasa ma być najkrótsza, czy optymalna z wagowego punktu widzenia. Przyjmuje parametr typu String o wartość BEST lub SHORTEST.
\end{itemize}

Przykładowe zapytanie HTTP GET w celu uzyskania odpowiedzi zawierającej optymalną trasę przejazdu można uzyskać pod adresem URL:

\url{bazowy_adres_url/api/routes/findOptimized?startLocation=romera&endLocation=karmelicka&routeType=BEST}

Przykładową odpowiedź, skróconą do postaci przedstawiającej jej formę przedstawiono poniżej.

\begin{center}
\includegraphics[height=12cm]{api_response_json}
\end{center}

\item Endpoint visualizationPoints:

Używany przez stronę internetową, będącą częścią przygotowanego systemu, w celu wizualizacji trasy na mapach openstreetmap. Wykorzystuje metodę HTTP GET. Możliwe parametry do przekazania w kwerendzie URL:

\begin{itemize}
\item startLocation - parametr określający początkową lokalizację użytkownika w postaci adresu.
\item endLocation - parametr określający końcową lokalizację użytkownika w postaci adresu.
\item routeType - określenie czy wyznaczona trasa ma być najkrótsza, czy optymalna z wagowego punktu widzenia. Przyjmuje parametr typu String o wartości BEST lub SHORTEST.
\item algorithm - parametr określający jaki algorytm ma zostać użyty do wyszukania trasy. Przyjmuje parametr typu String o wartości ASTAR, AGREEDY lub NBA.
\end{itemize}

Przykładowe zapytanie HTTP GET w celu uzyskania odpowiedzi zawierającej optymalną trasę przejazdu można uzyskać pod adresem URL:

\url{bazowy_adres_url/api/routes/visualizationPoints?startLocation=romera&endLocation=karmelicka&routeType=BEST&algorithm=ASTAR}

Przykładową odpowiedź, skróconą do postaci przedstawiającej jej formę przedstawiono poniżej:

\begin{center}
\includegraphics[height=12cm]{api_response_viz_json}
\end{center}

\end{enumerate}

\subsection{Proces wyznaczania grafu na podstawie pobranych danych}

W celu dodatkowej wizualizacji na poniższym schemacie blokowym przedstawiono proces wyznaczania grafu na podstawie pobranych danych geoprzestrzennych:

\begin{center}
\includegraphics[width=\textwidth]{algorytm_schemat_blokowy}
\end{center}

W celu optymalizacji czasu działania systemu, dane geoprzestrzenne są pobierane oraz przetwarzane przez aplikację tylko jeden raz, zaraz po włączeniu. Jest to czasochłonny proces, wymagający wielu iteracji po rozległym zbiorze danych. Jego rezultatem jest stworzenie grafu, który może być w kolejnych etapach wykorzystywany jako gotowa dana wejściowa. Tworzenie grafu zostaje rozpoczęte przez pobranie zestawu danych geoprzestrzennych dla miasta Kraków z portalu \textit{https://zikit.carto.com}. Pobrana baza danych zawiera zarówno trasy rowerowe, jak i drogi z ograniczeniem prędkości poniżej 50 kilometrów na godzinę, obydwie bazy są następnie scalane i przekształcane w zbiór odpowiednich dróg i segmentów. Droga jest logiczną reprezentacją krzywej poprowadzonej na mapie pomiędzy dwoma punktami, składa się z segmentów, które zawierają jedynie punkt początkowy oraz końcowy i definiują zestaw linii prostych, które mogą zostać użyte, aby narysować linię drogi na mapie. Wykorzystując metodę Haversine, zostają wyznaczone długości każdej drogi przez zsumowanie długości wszystkich segmentów, które się na nią składają. \newline
Kolejnym etapem jest proces przygotowywania dróg do procesu tworzenia grafu. Aby mieć pewność, że wszystkie przyległości zostaną poprawnie odnalezione, w pierwszym kroku należy odpowiednio podzielić wszystkie pobrane drogi na takie o mniejszej długości. Trasy pobrane z serwisu Carto mają bardzo losowe długości oraz są zaznaczone w taki sposób, że nie występuje segmentacja w okolicach końców innych tras oraz przy przecięciach z nimi. Z tego powodu wyznaczenie poprawnego grafu z uzyskanych danych wymaga wcześniejszego przetworzenia. Pierwszym krokiem przetwarzania danych jest podzielenie segmentów uzyskanych z przeanalizowanych, pobranych danych na takie, które mają maksymalnie trzy metry długości. Dzieje się to przez podział każdego segmentu na pół do momentu aż osiągną one pożądaną długość. W następnej kolejności, gdy posiadamy już podzielone segmenty, następuje podzielenie tras. Dzieje się to na zasadzie podzielenia tablicy segmentów na części o określonej długości a następnie utworzenia zestawu nowych dróg z uzyskanych części. Każda droga, stworzona przez podzielenie innej drogi na mniejsze części, posiada także przypisanie swojego "rodzica", czyli pierwotnej drogi z której nastąpił podział. Droga, będąca "rodzicem", posiada za to tablicę zawierająca wszystkie drogi będące jej "dziećmi". Na tym etapie następuje także przypisanie drodze odpowiedniej wagi oraz stwierdzenie czy droga przebiega po moście - jest to stwierdzane na podstawie wykrycia słów kluczowych „most” lub „kladka” w nazwie trasy. Niestety baza danych carto ZiKiT nie oferuje w swoich danych takich informacji, dlatego też występuje potrzeba przewidzenia tej danej w inny sposób. \newline
Proces tworzenia grafu rozpoczyna się od stworzenia wierzchołka w każdym miejscu będącym zakończeniem lub rozpoczęciem drogi. W tym celu następuje iteracja po wszystkich drogach będących "rodzicami", dla każdej z nich następuje iteracja po wszystkich jej "dzieciach" i tworzone są wierzchołki na początku pierwszej drogi oraz na zakończeniu każdej następnej. Każdy z utworzonych w tym procesie wierzchołków ma także przypisywaną trasę "rodzica", który jest "rodzicem" drogi, dla której wierzchołek został stworzony. Kolejnym etapem jest wyszukanie przyległości dla każdego z wierzchołków. W tym celu następuje zagnieżdżona iteracja po wszystkich stworzonych wierzchołkach i porównywana jest odległość pomiędzy nimi. W przypadku, gdy odległość ta jest mniejsza niż 40 metrów, następuje połączenie wierzchołków drogą o typie \textit{standard link}. W tym procesie ignorowane są wierzchołki posiadające takiego samego "rodzica", w celu uniknięcia łączenia wierzchołków już ze sobą połączonych w obrębie jednej drogi. Ignorowane są także wierzchołki których trasa-rodzic znajduje się na moście, wyodrębniając z tego wyjątek, gdy aktualnie rozpatrywany wierzchołek jest początkiem lub końcem trasy, do której przynależy. Zabieg ten ma na celu uniknięcie łączenia za sobą dróg znajdujących się na różnej wysokości.
W kolejnym kroku działania algorytmu, obsługiwane są drogi dwukierunkowe, są to takie które w polu kategoria zawierają jeden z poniższych skrótów:

\begin{itemize}
\item dwr - droga rowerowa.
\item cpr - ciąg pieszo-rowerowy.
\item c16t22 - chodnik z dopuszczonym ruchem rowerowym (skrót pochodzi od identyfikatora znaku drogowego).
\item kontrapas i kontraruch - zakładamy, że w tym przypadku użytkownik może poruszać się w przeciwną stronę po ulicy, na której znajduje się dana ścieżka.
\item skróty pokrewne zawierające kombinację powyższych lub dopisek w postaci cyfry.
\end{itemize}

Każda z dróg przypisanych do każdego z wierzchołków, w przypadku gdy jest oznaczona jako dwukierunkowa, musi zostać odpowiednio przetworzona, aby algorytm wyszukiwania mógł przez nią prowadzić. W tym celu wszystkie takie drogi wychodzące z wierzchołka zostają dodane do dróg wchodzących do wierzchołka, a następnie zostają odwrócone, czyli podmieniany jest identyfikator wierzchołka początkowego oraz końcowego, współrzędne końca i początku, a także w analogiczny sposób zostaje odwrócony każdy segment przynależący do danej drogi. Ta sama procedura zostaje powtórzona w celu transformacji także dróg wchodzących do wierzchołka.
Ostatnim z kroków przygotowywania grafu jest wyodrębnienie samotnych wierzchołków. Są to wierzchołki, które znajdują się w mało zagęszczonym drogami obszarze i znajdują się zbyt daleko, aby znaleźć dla nich przyległości, pomimo że powinny one zostać znalezione. Przykładem dla tego przypadku może być droga rowerowa na mało uczęszczanej ulicy, która w pewnym momencie z braku możliwości poprowadzenia zostaje przerwana na odcinku długości 100-150m, po czym następuje jej kontynuacja w obrębie tej samej ulicy. W tym celu dla każdego z wierzchołków, który posiada tylko jedną drogę przychodzącą, zostaje przeszukana okolica najbliższych 150 metrów. W przypadku znalezienia zbyt dużej ilości przyległości, proces jest ignorowany. W przeciwnym wypadku wierzchołek zostaje z nimi połączony drogą typu \textit{isolation link}. \newline

Po przeprowadzaniu całego powyższego procesu zostaje wygenerowany graf składający się z wierzchołków, w którym drogi pełnią rolę krawędzi. Ostatnim krokiem, przeprowadzanym podczas tworzenia docelowego grafu, jest przypisanie wagi każdej z dróg. Zważając na fakt, że baza danych carto zawiera informacje odnośnie typów większości tras, aplikacja stara się przewidzieć zysk użytkownika z przebycia dłuższego dystansu znacznie bardziej komfortowymi drogami. W tym celu przypisywane są w zależności od kategorii wagi:

\begin{itemize}
\item Ddr - waga 0.7
\item Cpr - waga 0.8
\item Kontrapas, kontraruch - waga 0.8
\item C16t22 - waga 0.9
\item Standard link - w przypadku, gdy krótszy niż 10 metrów, posiada wagę 1.5. W przeciwnym wypadku waga jest równa 2.
\item Isolatation link - waga 4
\item Droga rowerowa bez kategorii - waga 1
\item Droga z bazy sugerowanych tras - waga 1.2
\end{itemize}

\subsection{Opis procesu wyznaczania trasy dla użytkownika}

Kolejnym etapem działania algorytmu jest wyszukiwanie tras na podstawie danych wejściowych przekazanych przez użytkownika. Gdy zostanie zarejestrowane zapytanie pod endpoint „findOptimized”, aplikacja odpowiednio przetwarza dane w celu uzyskania współrzędnych geograficznych punktu początkowego oraz końcowego trasy. Wykorzystywany jest do tego serwis openstreetmap, odpowiednio skonfigurowany w celu dekodowania lokalizacji znajdujących się w Krakowie. W zależności od wybranej metody przeszukiwania brany jest także pod uwagę przekazany przez użytkownika parametr routeType. W przypadku przekazania drogi typu „BEST” przy tworzeniu odpowiedniego typu obiektu „graph”, używanego później do przeszukiwania, do połączenia każdego z wierzchołków używana jest rzeczywista waga drogi, za to w przypadku przekazania drogi typu „SHORTEST” ignorowane są wagi dróg i brana pod uwagę jest tylko ich całkowita długość.\newline
W następnym etapie graf zostaje przeszukany w celu znalezienia wierzchołków znajdujących się najbliżej pozycji wybranych przez użytkownika. W celu zminimalizowania prawdopodobieństwa sytuacji w której znalezione wierzchołki znajdują się w dwóch grafach które są wobec siebie rozbieżne, są także wyszukiwane wszystkie wierzchołki znajdujące się w otoczeniu 300 metrów od wyznaczonego najbliższego. Metoda ma na celu w głównej mierze wykluczenie wierzchołków przynależących do odosobnionych dróg rowerowych, które ze względu na zbyt dużą odległość nie zostały włączone do żadnego większego grafu i są reprezentowane przez odrębny graf składający się jedynie z jednej krawędzie i dwóch wierzchołków, wyznaczających początek i koniec drogi.
Kolejnym krokiem działania algorytmu jest wyznaczenie wszystkich możliwych ścieżek pomiędzy wszystkimi odnalezionymi punktami początkowymi i końcowymi. Wykorzystywany jest do tego algorytm A*. Każda z odnalezionych ścieżek ma przypisywaną zsumowaną wagę wszystkich dróg które do niej przynależą z wagą 1 oraz sumę odległości początku i końca ścieżki w stosunku do punktów początkowego i końcowego przekazanych przez użytkownika z wagą 20. Krok ten ma na calu eliminację dróg które są najkrótsze, ale są podzbiorem innej dłuższej drogi która prowadzi użytkownika tą samą trasą. Ze wszystkich wyznaczonych dróg zostaje wybrana ta która ma najmniejszą wagę.
Następnie wyznaczona ścieżka musi zostać odpowiednio przekształcona aby zawierała jak najkrótsze połączenia pomiędzy drogami które do niej przynależą. W tym celu zostają z niej wyeliminowane segmenty początkowe i końcowe każdej z dróg w przypadku gdy wykryto że prowadzą użytkownika okrężną drogą. Ostatnim etapem jest połączenie każdego punktu końcowego każdej drogi przynależącej do danej ścieżki z punktem początkowym kolejnej prostą drogą łącząca. \newline
Wyznaczona oraz przekształcona ścieżka zostaje zwrócona użytkownikowi w formie odpowiedzi w formacie JSON zawierającej współrzędne punktów początkowego i końcowego oraz zbioru dróg podzielonych na segmenty które pomiędzy nimi prowadzą.

\section{Opis stworzonej aplikacji mobilnej}

\subsection{Opis technologii}

Aplikacja mobilna została zaimplementowana pod system iOS przy użyciu SDK dostarczonego przez firmę Apple umożliwiającego implementację aplikacji. Implementację interfejsu użytkownika umożliwia biblioteka CocoaTouch będąca jego częścią. Z racji faktu że aplikacja wykorzystuje moduł GPS w celu wyznaczania aktualnego położenia użytkownika oraz bibliotekę MapKit wchodzącą w część biblioteki CocoaTouch, w poniższych akapitach opisano działanie obydwu bibliotek wraz z przykładami użycia wewnątrz zaimplementowanej aplikacji. \newline
CoreLocation jest biblioteką wchodzącą w skład iOS SDK. Oferuje interfejs do wyznaczania lokalizacji użytkownika ale odpowiada także za obsługę wielu innych sensorów obsługiwanych przez telefon jak na przykład magnetometru, barometru, a nawet Bluetooth - do wyznaczania położenia w stosunku do urządzeń w standardzie iBeacon. Przed uzyskaniem lokalizacji użytkownika, w celu ochrony prywatności, musi zostać wyświetlony odpowiedni komunikat, w którym użytkownik wyraża zgodę na udostępnienie swojej lokalizacji dla aplikacji. W następnej kolejności, przy użyciu delegacji klasy CLLocationManager aplikacja uzyskuje co sekundę odpowiedź zwrotną zawierająca aktualną lokalizację użytkownika a także jej dokładność w metrach. Biblioteka CoreLocation jest także używana do wyznaczania kierunku w którym użytkowni skierował swój telefon. Umożliwia to płynną animację ikony roweru podczas prowadzenia użytkownika po trasie, w interfejsie użytkownika jest on skierowany w tę samą stronę na mapie, co telefon w rzeczywistości. Dodatkową funkcją biblioteki wykorzystywaną w aplikacji jest geocoding, czyli wyznaczanie współrzędnych geograficznych na podstawie wpisanego tekstu adresu lub działanie do tego odwrotne. Użyta została do tego klasa CLGeocoder będąca częścią CoreLocation. \newline
Drugą biblioteką zapewniającą działanie aplikacji iOS jest MapKit - biblioteka umożliwiająca wyświetlanie map na ekranie telefonu. Została wybrana w stosunku do map Google z racji na prostszą implementację w aplikacjach pisanych na system iOS a także fakt że jest rozwiązaniem natywnym, zaimplementowanym przez firmę Apple, nie zewnętrzną biblioteką.

\subsection{Schemat klas aplikacji mobilnej}

Za zarządzanie danymi oraz stanem aplikacji odpowiada klasa NavigationManager, jest to swojego rodzaju łącznik pomiędzy widokiem głównym a wszelkimi serwisami takimi jak klient nawigacji lub serwis zapewniający lokalizację użytkownika lub klasa odpowiedzialna za wykonywanie zapytań HTTP. Zarządza w odpowiedni sposób danymi wejściowymi oraz interakcjami użytkownika przekazanymi z ekranu głównego aby zareagować odpowiednimi akcjami i zmianą stanu który następnie przekazany do warstwy widoku przez delegację odpowiada za wyświetlenie odpowiednich danych dla użytkownika. Do odpowiedzialności klasy NavigationManager należą:

\begin{enumerate}
\item Obserwacja danych wpisywanych przez użytkownika do pól punktu startowego oraz końcowego.
\item Obsługa przycisku wyznaczenia aktualnego adresu użytkownika. Po jego wciśnięciu do klasy zostaje przekazane odpowiednie zdarzenie na które reaguje dekodowaniem aktualnej lokalizacji użytkownika na adres na mapie.
\item Pobranie trasy przy użyciu endpointu „findOptimized” po akcji użytkownika w postaci przyciśnięcia przycisku „Navigate” oraz zmianę stanu aplikacji na zaznaczenie trasy gdy zapytanie się powiedzie.
\item Włączenie oraz wyłączenie procesu nawigowania użytkownika w przypadku gdy została zatrzymana przez użytkownika lub znalazł się on w punkcie końcowym.
\item Na poniższej ilustracji przedstawiono schemat działania aplikacji razem z interakcjami pomiędzy jej komponentami:
\end{enumerate}

// tutaj idzie schemat aplikacji.

\subsection{Spis ekranów i stanów aplikacji}

Zaimplementowana aplikacja mobilna składa się z zestawu ekranów które umożliwiają użytkownikowi intuicyjne wprowadzenie parametrów trasy oraz przejście przez każdy stan nawigacji aż do doprowadzenia do końca trasy. W poniższych akapitach zestawiono przykładowe ekrany aplikacji wraz z opisem ich celu i możliwych interakcji ze strony użytkownika.
Bezpośrednio po wejściu do aplikacji, użytkownikowi zostaje przedstawiony ekran z mapą oraz dwoma polami tekstowymi, każde z nich posiada placeholder w celu zasugerowania którą z wartości należy wpisać. Po prawej stronie pola tekstowego służącego do pisania adresu początkowego znajduje się przycisk lokalizowania użytkownika. Po kliknięciu aplikacja pobiera z modułu GPS aktualną pozycję użytkownika, a następnie używając wbudowanej w iOS SDK klasy CLGeocoder wykonuje translację współrzędnych geograficznych na tekstową reprezentację adresu. Wyznaczony adres zostaje wpisany w pole tekstowe. Na poniższej ilustracji przedstawiono ekran początkowy w stanie gdy nie ma wprowadzonych danych.

\begin{center}
\includegraphics[height=12cm]{navi_initial}
\end{center}

Po wprowadzeniu punktów końcowych trasy, następuje jej wyszukanie, w tym celu aplikacji przygotowuje zapytanie pod endpoint „findOptimized” przekazując dane wpisane w polach tekstowych, a na czas ładowania odpowiedzi wyświetla indykator ładowania na górnym panelu oraz blokuje interakcje użytkownika ze wszystkimi elementami interfejsu użytkownika poza mapą. Po pobraniu trasy jest ona przekształcana na modele po stronie aplikacji oraz rysowana na mapie. Linią ciągłą zaznaczona jest trasa, linią przerywaną odcinki poza trasowe które trzeba pokonać aby dostać się z aktualnej lokalizacji użytkownika do początku trasy oraz z końca trasy do punktu końcowego wprowadzonego przez użytkownika. W celu odpowiedniej wizualizacji, po narysowaniu mapa jest odpowiednio przybliżana aby pokazać użytkownikowi przebieg całej trasy od jej początku do końca. Ekran z narysowaną mapą przedstawiono na poniższej ilustracji.

\begin{center}
\includegraphics[height=12cm]{navi_route_marked}
\end{center}

Po wciśnięciu przycisku nawiguj zostaje włączony proces nawigacji użytkownika po trasie. W pierwszej fazie jest to prowadzenie do początku trasy, mapa zostaje odpowiednio przybliżona aby objąć trasę z punktu początkowego na początek trasy, lokalizacja użytkownika jest przedstawiona w postaci standardowego punkty na mapie obsługiwanego przez bibliotekę MapKit.

\begin{center}
\includegraphics[height=12cm]{navi_reach_start}
\end{center}

Po dojściu użytkownika w obręb wyznaczonej trasy, interfejs użytkownika rozpoczyna nawigowanie go po trasie. Punkt wyznaczający aktualną lokalizację jest co sekundę animowanie przesuwany na pozycję na trasie odpowiadającą najbliższemu segmentowi w stosunku do rzeczywistej pozycji użytkownika na mapie. W przypadku wykrycia przez aplikację zakrętu w obrębie około najbliższych 200 metrów, na górnym panelu jest wyświetlana wskazówka zawierająca kierunek zakrętu oraz aktualną odległość po której wystąpi. W przypadku gdy użytkownik zjedzie z trasy, na górnym panelu jest przedstawiona instrukcja sugerująca powrót na trasę, zaś gdy oddali się od niej za daleko, instrukcja zmienia się w informację o wyznaczaniu nowej trasy do punktu końcowego.

\begin{center}
\includegraphics[height=12cm]{navi_guidance}
\end{center}

\subsection{Opis działania nawigacji}

System nawigacji w aplikacji został zaimplementowany w celu wizualizacji aktualnej lokalizacji użytkownika w stosunku do trasy która została wyznaczona. Działanie systemu składa się z zestawu stanów pomiędzy którymi algorytm może przechodzić w przypadku wykrycia określonych warunków. W poniższym akapicie została przedstawiona lista stanów na które składa się proces nawigacji a także dokładny opis warunków koniecznych do przejścia pomiędzy nimi. W celu wizualizacji procesu został także stworzony diagram stanów odwzorowujący cały proces.

Lista stanów w których może znaleźć się proces nawigacji użytkownika:

\begin{itemize}
\item Dojście z aktualnej lokalizacji do punktu startowego trasy
\item Nawigacja użytkownika po trasie
\item Dojście z końca trasy do punktu końcowego nawigacji
\item Zejście z trasy - w przypadku gdy użytkownik znalazł się więcej niż 30m ale nie więcej niż 150m od trasy.
\item Potrzeba wyznaczenia nowej trasy - gdy użytkownik znalazł się dalej niż 150m od najbliższego segmentu trasy.
\end{itemize}

W momencie gdy użytkownik rozpoczyna nawigację, zostaje włączony proces który co sekundę pobiera aktualną lokalizację użytkownika z klienta lokalizacji i wyznacza aktualny stan aplikacji. Startowym stanem jest prowadzenie użytkownika do początku trasy. Jako że pokrycie Krakowa ścieżkami rowerowymi oraz drogami z niskim ograniczenie prędkości jest względnie małe, w większości przypadków użytkownik na początku będzie musiał przemieścić się kilkaset metrów poza trasami wspieranymi przez aplikację. W tym celu jest rysowana prosta linia pomiędzy punktem początkowym, wpisanym przez użytkownika, a początkiem trasy a mapa jest odpowiednio przybliżana aby umożliwić użytkownikowi proste dotarcie na drogę. \newline
W czasie fazy prowadzenia użytkownika na start trasy, co każdy cykl odświeżenia aktualnego stanu, jest sprawdzane czy użytkownik znalazł się w otoczeniu 10 metrów w stosunku do początku któregokolwiek z segmentów składających się na trasę. Sprawdzanie jedynie segmentu będącego punktem początkowym trasy nie daje w tym wypadku oczekiwanego rezultatu ze względu na częste błędy w wyznaczeniu pozycji użytkownika przez moduł GPS a także przez fakt że często na trasę wjeżdżamy nie dokładnie w punkcie jej początku a przykładowo dopiero po pierwszych stu metrach. Posiadając dostępny zbiór danych aplikacja nie jest w stanie niestety wyznaczyć optymalnej trasy użytkownika pomiędzy jego aktualnym położeniem a punktem końcowym trasy. Jesteśmy w stanie jedynie oszacować że najbardziej prawdopodobnym punktem będzie najbliższy wierzchołek grafu zakładając ich odpowiednią granulację otrzymaną podczas procesy jego tworzenia. \newline
W przypadku wykrycia wejścia użytkownika w obręb wyznaczonej dla niego trasy aplikacja przechodzi w stan nawigowania po trasie. Aby uniknąć błędów w wyznaczaniu pozycji użytkownika i prowadzenia go 10-20 metrów obok zaznaczonej drogi, został zaimplementowany mechanizm dociągania do wyznaczonej ścieżki. W tym celu w każdym kroku filtrowane są wszystkie drogi w celu znalezienia tej znajdującej się najbliżej użytkownika, zastosowano do tego porównanie sumy odległości od początków z każdej tych dróg, podzielonej przez jej długość. Dzięki temu rozwiązaniu algorytm wyeliminował znajdywanie jedynie krótkich dróg dla których suma odległości do początku oraz do końca była najmniejsza. \newline
Po odnalezieniu najbliższej drogi, algorytm przeszukuje wszystkie jej segmenty w celu znalezienia tego znajdującego się najbliżej. Jako że długości segmentów zostały ujednolicone w jednym z kroków tworzenia grafu, na tym etapie możemy zastosować prostsze porównanie które sprawdza jedynie sumę odległości użytkownika od początku oraz końca każdego z segmentów.
W następnym kroku, uzyskany segment zostaje podzielony na 20 równych sobie odcinków, najbliższy aktualnej pozycji użytkownika zostaje przypisany jako najbardziej odpowiedni a aplikacja sztucznie dociąga lokalizację użytkownika do tego właśnie punktu. \newline
Powyżej opisana metoda działa w przypadku gdy wyznaczona pozycja użytkownika znajduje się nie dalej niż 50 metrów od trasy. W przypadku gdy użytkownik znajdzie się w odległości większej niż 50 metrów, algorytm przestaje zwracać pozycję użytkownika dociągniętą do trasy a zamiast tego zwraca rzeczywiste położenie użytkownika na mapie. Ten tryb został zaimplementowany w celu pokazania użytkownikowi informacji że znalazł się poza trasą i powinien na nią wrócić. Ogranicza to także niepotrzebne zapytania do strony serwerowej w przypadku gdy użytkownik celowo zszedł z trasy aby na przykład wejść do sklepu.
W przypadku gdy wykryte położenie znajduje się dalej niż 150m od trasy zaznaczonej na mapie, algorytm zakłada że należy dla użytkownika wyznaczyć nową trasę, o czym informuje przez wysłanie określonego sygnału oraz zakończenie działania. W tym momencie zostaje wysłane zapytanie do serwera o nową trasę zawierające aktualną pozycję użytkownika oraz miejsce docelowe określone na początku procesu nawigacji. W przypadku gdy zapytanie się powiedzie, algorytm zostaje zrestartowany i wraca do stanu początkowego, czyli prowadzenia użytkownika do początku trasy.
W każdym kroku działania algorytmu jest także sprawdzana odległość aktualnej pozycji użytkownika w stosunku do końca wyznaczonej trasy. Jeśli ta jest mniejsza niż 50 metrów, zakładamy że użytkownik dotarł do końca i nawigacja przechodzi w tryb prowadzenia użytkownika do punktu końcowego trasy, pokazując jednocześnie odpowiednio przybliżony obszar na mapie. W tym kroku założona odległość od punktu końcowego musi być znacznie większa niż ta która stanowi o momencie wejścia na trasę ponieważ użytkownik może znajdywać się w najbliższym otoczeniu punktu końcowego jedynie przez krótką chwilę.


\subsection{Opis testów}

Do testów działania nawigacji zostały wykorzystane pliki GPX(GPS Exchange Format) które, sformatowane w odpowiedni sposób umożliwiają symulację lokalizacji użytkownika zarówno przy użyciu symulatora jak i na rzeczywistym urządzeniu z systemem iOS. Plik GPX jest to plik w formacie XML który składa się. Ze zbioru punktów oraz czasów skorelowanych z każdym z punktów. System odczytując ten plik animuje lokalizację użytkownika tak aby przeszła pomiędzy wszystkimi określonymi punktami w ściśle wyznaczonym czasie. Do stworzenia plików użyto strony http://www.gpsies.com/createTrack.do która udostępnia graficzny interfejs do zaznaczania punktów na mapie oraz określenia z jaką prędkością chcielibyśmy aby użytkownik się pomiędzy nimi przemieszczał. Pobrany stamtąd plik następnie trzeba poddać obróbce w postaci usunięcia kilku linii aby był wspierany przez symulację lokalizacji w systemie iOS.

\section{Opis stworzonej strony internetowej}

\subsection{Opis technologii i użytych bibliotek}

W ramach projektu została zaimplementowana także strona internetowa, która w intuicyjny sposób pozwala użytkownikowi wyszukać trasę pomiędzy wpisanymi adresami oraz wyświetla ją na mapie. 
Aplikacja została stworzona w oparciu o bibliotekę ReactJS która pozwala w szybki sposób zbudować prototyp strony internetowej przy użyciu języka Javascript oraz predefiniowanych elementów strony takich jak przyciski czy pola tekstowe. Do wyświetlenia map użyto map udostępnionych przez openstreetmap przez bibliotekę React Leaflet. Leaflet jest to biblioteka umożliwiająca bardzo proste renderowanie map przy użyciu Javascript, React Leaflet dodaje do tego mapy w postacie gotowych komponentów React. Wybór został podyktowany faktem, że prostsze w użyciu i wydajniejsze mapy Google w celu wyświetlenia przy użyciu języka Javascript wymagają płatnej subskrybcji.
W projekcie strony internetowej, do zarządzania zewnętrznymi zależnościami użyto programu yarn, a do zapytań http użyto biblioteki axios. Narzędzia te nie różnią się od tych dla aplikacji serwerowej, dlatego też w tym akapicie pominięto ich opis.

\subsection{Spis ekranów, opis działania}

Aplikacja jest bardzo prosta, składa się z dwóch ekranów. Na pierwszym z nich są przedstawione dwa pola tekstowe oraz przycisk umożliwiający wyszukanie trasy, jego wygląd przedstawiono na poniższej ilustracji.

\begin{center}
\includegraphics[width=\textwidth]{web_form}
\end{center}

Kolejny z ekranów ma zaimplementowaną logikę pobierania trasy w zależności od stanu przekazanego do niego z ekranu wpisywania danych. Wykorzystując bibliotekę axios wykonuje zapytanie pod endpoint „visualizationPoints” zawierając w kwerendzie wymagane dane. Zwrócona odpowiedź w formacie JSON zawiera zbiór wszystkich punktów na mapie który należy ze sobą połączyć aby przestawić użytkownikowi wizualizację wyznaczonej ścieżki. Ścieżka jest przedstawiona na mapie obejmującej całość ekranu.

\begin{center}
\includegraphics[width=\textwidth]{web_map}
\end{center}